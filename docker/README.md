# :whale: Docker 

- 컨테이너 기술들은 여러가지 있는데 이 컨테이너를 배포하고 관리하는 게 어렵다. 이걸 도와주는 도구들이 쿠버네티스, 아마존 엘라스틱 컨테이너 서비스 등이 있고
Docker 도 **컨테이너 가상화 도구** 중의 하나다.

## 장점
- 다른 사람이 만든 서버를 가져다 쓸 수 있고, 여러 대에 배포할 수 있다. ==> 편리함과 확장성을 지님
- So, 개발환경이 다른 눈송이 서버들의 문제점을 보완해준다. (컴파일러, 설치된 패키지 등 모두 같기 힘들다.)
- 컨테이너로 프로세스를 격리시켜서 사용하기 때문에 가볍게 느껴진다.
- 레이어 개념을 사용한다.
- 동일한 인터페이스를 제공할 수 있기 때문에 프로그램 배포 및 관리를 단순하게 해준다.

## 이미지
> 컨테이너 실행에 필요한 파일과 설정값을 포함하고 있는 것.

- 컨테이너의 상태를 그대로 이미지로 찍어서 저장하고 있다고 생각하자.
- 도커 이미지는 Docker hub 에 등록하거나 Docker Registry 저장소를 직접 만들어 관리한다.
- 이미지는 url 방식으로 관리하며 태그를 붙일 수 있다.

### 이미지 이름
> [Registry URL]/[사용자 id]/[이미지명]:[tag]

- Url 은 생략될 수 있다.
- Url 은 기본적으로 도커 허브를 바라보고 있다.

## 컨테이너
> 다양한 프로그램을 실행하는 환경을 컨테이너라 한다.

- 이미지를 실행한 상태인 **프로세스**이기 때문에 실행중인 프로세스가 없으면 곧바로 종료된다.
- 같은 이미지에서 여러개의 컨테이너를 생성할 수 있다.
- 컨테이너의 상태가 바뀌거나 컨테이너가 삭제 되더라도 이미지는 변하지 않고 그대로 남아있는다. 
- 읽기-쓰기가 가능한 레이어를 추가해서 컨테이너가 실행되는 도중에 새로 생성되는 부분은 이곳에 저장한다.
결국엔 여러 개의 컨테이너를 생성해도 최소한의 용량만 사용된다.

## 명령어
- 터미널에 `Docker version` 을 입력하면 Client 와 server 가 나오는데, 
도커는 하나의 실행파일이지만 클라와 서버 역할을 수행할 수 있음을 보여준다.

- `ps` 리스트 출력
- `rm` 컨테이너 제거
- `rmi` 이미지 제거
- `run` 컨테이너를 새로 만들어서 실행
- `exec` 실행중인 컨테이너에 명령어를 내림
- `build` 이미지 빌드
- `-d` detached mode 백그라운드 모드
- `-p` 포트 포워딩 로컬포트:도커서버포트
- `-v` 호스트와 컨테이너의 디렉토리를 연결 (마운트)
- `-v` /my/own/datadir:/var/lib/mysql
- `-e` 컨테이너 내에서 사용할 환경변수 설정
- `-name` 이름 지정
- `-rm` 프로세스 종료시 컨테이너 자동 제거
- `-it` 컨테이너명 /bin/bash : 실행 프로그램 안에 들어가서 bash 로 접근하게 해줌.
- `-link` 컨테이너 연결 [컨테이너명:별칭]
- `-t` 태그. 도커 이미지에 태그를 넣는다. 
> `Docker tag app naanace/sinatra-app:1`
> naanace 라는 id 를 사용하고, 이미지 이름을 Sinatra-app 으로 변경함.

## Dockerfile
> 이미지를 만드는 과정을 담은 파일

- 명령어가 수정되었거나 추가하는 파일이 변경 되었을 때 캐시가 깨지고, 그 이후 작업은 새로 이미지를 만들게 된다.

### command
- `FROM` 베이스 이미지
- `MAINTAINER` docker 를 관리하는 사람의 이름 또는 메일
- `COPY` `<src> … <dest>` 파일이나 디렉토리를 이미지로 복사
- `ADD` `<src> … <dest>` 파일 대신 url 도 입력할 수 있고 압축파일도 자동으로 압축해제하면서 복사.
- `RUN` shell 에서 실행될 명령어.
- `CMD` 도커 컨테이너 안에서 실행될 명령어.
- `WORKDIR` run, cmd, add, copy 등이 이루어질 기본 디렉토리. 각 명령어의 현재 디렉토리는 한 줄 마다 초기화 되기 때문에 항상 같은 디렉토리에서 작업하기 위해선 WORKDIR 사용.
- `EXPOSE` 컨테이너 실행됐을 때 요청 기다리는 포트 지정. 여러개 가능.
- `VOLUME` 컨테이너 외부에 파일시스템 마운트 할 때 사용.
- `ENV` 컨테이너에서 사용할 환경변수.

## Docker-compose
컨테이너 조합이 많아지고 여러가지 설정이 추가되기 때문에 이러한 복잡한 설정들을 모은 yaml 방식의 설정파일을 사용할 수 있다.
- :star2:[docker-compose 설정 docs](https://docs.docker.com/compose/compose-file/#dockerfile)

### command
```yaml
build: --> 이미지 빌드
    context: --> 빌드 실행할 경로
image: --> 컨테이너가 시작될 이미지 시점
```
## Dockerfile 과 docker-compose 차이
- [racconyy 님 링크](http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/)의 `1.6 도커 컴포즈` 사진을 참고.
- Dockerfile = 서버운영기록. (+장황한 옵션)
- 도커 이미지 = Dockerfile + 실행시점
- 도커 컨테이너 = 도커이미지 + 환경변수
- docker-compose = 컨테이너에 여럿을 띄우는 도커 어플리케이션을 정의하고 실행하는 도구

## 컨테이너를 업데이트 하려면?
1) 새 버전의 이미지를 다운받고 (pull) 
2) 기존 컨테이너를 삭제(stop, rm)한 후
3) 새 이미지를 기반으로 새 컨테이너를 실행(run)

컨테이너를 삭제하면 그 안에 있던 데이터들은 전부 삭제가 되니, aws s3 같은 클라우드 서비스를 이용해 외부에서 데이터를 저장해야 한다. (또는 컨테이너와 별도로 저장되는 데이터 볼륨 사용)

## 도커 빌드 과정
임시 컨테이너 생성 > 명령어 수행 > 이미지로 저장 > 임시 컨테이너 삭제 >
새로 만든 이미지 기반 임시 컨테이너 생성 > 명령어 수행 > 이미지로 저장 > 임시 컨테이너 삭제 >
새로 만든 이미지 기반 임시 컨테이너 생성 > 명령어 수행 > 이미지로 저장 > 임시 컨테이너 삭제 > …

- 한 번 빌드한 이미지를 다시 빌드하면 굉장히 빠르게 완료된다. 각 단계가 캐시로 저장되기 때문.
- Dockerfile 명령어 수정하거나 추가하는 파일이 변경될 때 캐시가 깨지고, 그 이후 작업은 새로 이미지를 만든다.

## 도커 이미지 전송

`Docker push naanace/sinatra-app:1` 만들어진 이미지를 도커 허브에 이미지를 전송한다.

## 기타 참고
- 레디스 : 메모리 기반의 다양한 기능을 가진 스토리지

## 참고 사이트
- [초보자를 위한 도커 안내서](https://subicura.com/2017/01/19/docker-guide-for-beginners-1.html)
- [Docker (Compose)활용법 - 개발 환경 구성하기](http://raccoonyy.github.io/docker-usages-for-dev-environment-setup/)
