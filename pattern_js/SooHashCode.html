
<!DOCTYPE html>
<head>
  <meta charset="utf-8" />
  <title> Make Hash code function</title>
</head>
<body>
  <input id="originalText" type="input" />
  <label id="result"></label>
  <button type="button">해시코드 변환</button>
   <script type="text/javascript">
    // https://ratsgo.github.io/data%20structure&algorithm/2017/10/25/hash/
    // http://bcho.tistory.com/1072
    // http://hyeonstorage.tistory.com/265
    // Hello Coding 그림으로 개념을 이해하는 알고리즘, (공)저:아디트야 바르가바, 한빛미디어
    // linked-list http://jinbroing.tistory.com/149

    // hashTable : Array
    // hashTable value : Linked List
    // methods : insert, delete, search

    // hashTable size = 11
    // (one address, several datas) : chaining
    // (one address, one data): open addressing

    // apple -> (idx, data)
    //            1 , apple

    var SooHashCode = (function() {
        var sooHashCode = function() {
          this.size = 10;
          this.deleteWord = "DEL";
          this.hashTable = new Array(this.size);
          this.linkedList = new SooLinkedList();
        };

        sooHashCode.prototype.Contains = function (key) {
            var idx = key % this.size;
            return this.hashTable[idx];
        };

        sooHashCode.prototype.RemoveKey = function (key) {
            this.hashTable[key] = this.deleteWord;
            return this.hashTable;
        };

        sooHashCode.prototype.CollisionMaxCount = function () {
          var count = 0;
          return count;
        };

        sooHashCode.prototype.Put = function (key) {

            // convert key to unicode
            var unicodeKey = "";
            for (var idx = 0; idx < key.length; idx++) {
                unicodeKey += key.charCodeAt(idx);
            }

            // make linkedlist each hash bucket!!!! ---->
            var hashCode = this.HashFunction(unicodeKey);

            // save to linkedList
            console.log(this.linkedList.append(key));

//            if (!this.Contains(hashCode)) {
//                this.hashTable[hashCode] =
//                    {
//                        Key : unicodeKey,
//                        Value : key
//                    };
//            }
//
//            console.log(this.hashTable);
            return hashCode;
        };

        sooHashCode.prototype.Get = function (idx) {
            return this.hashTable[idx];
        }

        sooHashCode.prototype.HashFunction = function (key) {
            return key % this.size;
        }

        return sooHashCode;
    })();

    var SooLinkedList = (function() {
        function Node(data) {
            this.data = data;
            this.next = null;
        }

        var sooLinkedList = function() {
            this._length = 0;    // data length in linked-list
            this._head = null;   // start point
        }

        sooLinkedList.prototype.append = function(data) {
            var node = new Node(data);
            var currNode;

            // set start node
            if (this._head == null) {
                this._head = node;
            }
            else {
                // set next node
                currNode = this._head;
                while(currNode.next) {
                    currNode = currNode.next;
                }
                currNode.next = node;
            }

            this._length++;
            return this;
        }

        return sooLinkedList;
    })();

    var sooLinkedList = new SooLinkedList();
    // sooLinkedList.append("one");
    // sooLinkedList.append("two");

    var sooHashCode = new SooHashCode();
    console.log(sooHashCode.Put("apple"));
    console.log(sooHashCode.Put("avocado"));
    console.log(sooHashCode.Put("banana"));
    console.log(sooHashCode.Put("blueberry"));
    console.log(sooHashCode.Put("strawberry"));
//
//    console.log(sooHashCode.Get(1));
//
//    console.log(sooHashCode.RemoveKey(7));
      // sooHashCode.RemoveKey(99);

  </script>
</body>
</html>
